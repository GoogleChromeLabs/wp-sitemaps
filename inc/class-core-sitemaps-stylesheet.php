<?php
/**
 * Sitemaps: Core_Sitemaps_Stylesheet class
 *
 * This class provides the XSL stylesheets to style all sitemaps.
 *
 * @package WordPress
 * @subpackage Sitemaps
 * @since x.x.x
 */

/**
 * Stylesheet provider class.
 */
class Core_Sitemaps_Stylesheet {
	/**
	 * Renders the xsl stylesheet depending on whether its the sitemap index or not.
	 */
	public function render_stylesheet() {
		$stylesheet_query = get_query_var( 'sitemap-stylesheet' );

		if ( ! empty( $stylesheet_query ) ) {
			header( 'Content-type: application/xml; charset=UTF-8' );

			if ( 'xsl' === $stylesheet_query ) {
				// phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- All content escaped below.
				echo $this->get_sitemap_stylesheet();
			}

			if ( 'index' === $stylesheet_query ) {
				// phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- All content escaped below.
				echo $this->get_sitemap_index_stylesheet();
			}

			exit;
		}
	}

	/**
	 * Returns the escaped xsl for all sitemaps, except index.
	 */
	public function get_sitemap_stylesheet() {
		$css             = $this->get_stylesheet_css();
		$column_headings = $this->get_stylesheet_column_headings();
		$title           = esc_xml__( 'XML Sitemap', 'core-sitemaps' );
		$description     = sprintf(
			/* translators: %s: URL to sitemaps documentation. */
			__( 'This XML Sitemap is generated by WordPress to make your content more visible for search engines. Learn more about XML sitemaps on <a href="%s">sitemaps.org</a>.', 'core-sitemaps' ),
			__( 'https://www.sitemaps.org/', 'core-sitemaps' )
		);
		$text            = sprintf(
			/* translators: %s: number of URLs. */
			__( 'This XML Sitemap contains %s URLs.', 'core-sitemaps' ),
			'<xsl:value-of select="count(sitemap:urlset/sitemap:url)"/>'
		);

		$xsl_content = <<<XSL
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
		version="1.0"
		xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
		xmlns:sitemap="http://www.sitemaps.org/schemas/sitemap/0.9"
		xmlns:wp="urn:wordpress.org/core-sitemaps"
		xmlns:exsl="http://exslt.org/common"
		xmlns:msxsl="urn:schemas-microsoft-com:xslt"
		extension-element-prefixes="exsl msxsl"
		exclude-result-prefixes="sitemap wp"
		>
	<xsl:output method="html" encoding="UTF-8" indent="yes" />

	<!--
		Define a key over all distinct element children of Q{http://www.sitemaps.org/schemas/sitemap/0.9}url.

		Key values are the {@link https://www.w3.org/TR/xpath-30/#prod-xpath30-URIQualifiedName URIQualifiedName} of
		each distinct child element.

		@see the comment before the declaration of the "columns" variable below.
	  -->
	<xsl:key
		name="distinct-url-children"
		match="//sitemap:urlset/sitemap:url/*"
		use="concat( 'Q{', namespace-uri(), '}', local-name() )"
	/>

	<!--
		Lookup table for mapping column @namespace-uri and @local-name pairs to column headings text.
	  -->
	<wp:column-headings>
		$column_headings
	</wp:column-headings>
	<!--
		Convert the column headings lookup table to a node set and store the node set in a variable.

		Note that, unlike the columns themselves, we can convert the headings to
		a node-set via {@link https://www.w3.org/TR/1999/REC-xslt-19991116#function-document document()}
		without needing to use the node-set() extension function.
	  -->
	<xsl:variable name="column-headings" select="document( '' )/*/wp:column-headings" />

	<xsl:template match="/">
		<!--
			Gather all distinct elements that appear as children of
			Q{http://www.sitemaps.org/schemas/sitemap/0.9}url in the sitemap
			and store them in a variable, so that they can be iterated over
			to generate the HTML table.

			Since no browsers currently support XSLT 2.0+, and hence don't support the
			xsl:for-each-group instruction,	we use
			{@link http://www.jenitennison.com/xslt/grouping/muenchian.html Muenchian Grouping}
			gather the distinct children.

			The columns will be in the following order (regardless of what
			other the elements appear in in the sitemap, including different
			orders for different Q{http://www.sitemaps.org/schemas/sitemap/0.9}url elements):

			1. columns for all elements in the http://www.sitemaps.org/schemas/sitemap/0.9
			   namespace will come before those in extension namespaces.

			   a. elements defined in the sitemap {@link http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd XML Schema}
			      will be in the order of the content model for Q{http://www.sitemaps.org/schemas/sitemap/0.9}url
			   b. elements not defined in the sitemap XML Schema will ordered by their
			      local-name() after those that are defined in the XML Schema.
			2. columns for all elements in extension namespaces will be ordered by
			   a. their namespace-uri()
			   b. their local-name()
		  -->
		<xsl:variable name="columns">
			<!--
				Since XSLT 1.0 will create this variable as a
				{@link https://www.w3.org/TR/1999/REC-xslt-19991116#section-Result-Tree-Fragments Result Tree Fragment}
				we'll have to convert it to a node set to iterate over it.  To do that, we'll have
				to use the extension function node-set().  If node-set() is not available,
				we won't bother to gather columns, because we won't be able to iterate over them.
				In that case, the HTML table will only contain the URL column.

				{@link http://exslt.org/exsl/functions/node-set/ exsl:node-set()} is supported in Chrome, FF
				and many other browsers.
				{@link https://docs.microsoft.com/en-us/dotnet/standard/data/xml/support-for-the-msxsl-node-set-function msxsl:node-set()}
				is supported in Edge and IE (11).
			  -->
			<xsl:if test="function-available( 'exsl:node-set' ) or function-available( 'msxsl:node-set' )">
				<xsl:for-each select="//sitemap:urlset/sitemap:url/*[
						namespace-uri() = 'http://www.sitemaps.org/schemas/sitemap/0.9' and
						generate-id() = generate-id( key( 'distinct-url-children', concat( 'Q{', namespace-uri(), '}', local-name() ) )[1] ) ]">
					<!--
						 Force the columns to be in the order defined by the sitemaps
						 XML Schema content model for Q{http://www.sitemaps.org/schemas/sitemap/0.9}url
					  -->
					<xsl:sort select="number( local-name() = 'loc' )" order="descending" />
					<xsl:sort select="number( local-name() = 'lastmod' )" order="descending" />
					<xsl:sort select="number( local-name() = 'changefreq' )" order="descending" />
					<xsl:sort select="number( local-name() = 'priority' )" order="descending" />

					<!-- then alpha for all elements in the sitemaps namespace that aren't in the schema. -->
					<xsl:sort select="local-name()" />

					<wp:column namespace-uri="{namespace-uri()}" local-name="{local-name()}" />
				</xsl:for-each>

				<!-- then, get those elements in extension namespaces -->
				<xsl:for-each select="//sitemap:urlset/sitemap:url/*[
						namespace-uri() != 'http://www.sitemaps.org/schemas/sitemap/0.9' and
						generate-id() = generate-id( key( 'distinct-url-children', concat( 'Q{', namespace-uri(), '}', local-name() ) )[1] ) ]">
					<!-- order them by namespace-uri() and then local-name() -->
					<xsl:sort select="namespace-uri()" />
					<xsl:sort select="local-name()" />

					<wp:column namespace-uri="{namespace-uri()}" local-name="{local-name()}" />
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>

		<html>
			<head>
				<title>$title</title>
				<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
				<style type="text/css">
					$css
				</style>
			</head>
			<body>
				<div id="sitemap__header">
					<h1>$title</h1>
					<p>$description</p>
				</div>
				<div id="sitemap__content">
					<p class="text">$text</p>

					<table id="sitemap__table">
						<thead>
							<tr>
								<xsl:choose>
									<!-- Iterate over \$columns (if possible). -->
									<xsl:when test="function-available( 'exsl:node-set' )">
										<xsl:apply-templates select="exsl:node-set( \$columns )/*" mode="table-header" />
									</xsl:when>
									<xsl:when test="function-available( 'msxsl:node-set' )">
										<xsl:apply-templates select="msxsl:node-set( \$columns )/*" mode="table-header" />
									</xsl:when>
									<xsl:otherwise>
										<!-- Fallback: browser doesn't support node-set(), so output just the URL column. -->
										<th>
											<xsl:value-of select="\$column-headings/wp:column-heading[@namespace-uri = 'http://www.sitemaps.org/schemas/sitemap/0.9' and @local-name='loc']"  />
										</th>
									</xsl:otherwise>
								</xsl:choose>
							</tr>
						</thead>
						<tbody>
							<xsl:for-each select="sitemap:urlset/sitemap:url">
								<tr>
									<xsl:choose>
										<!-- Iterate over \$columns (if possible). -->
										<xsl:when test="function-available( 'exsl:node-set' )">
											<xsl:apply-templates select="exsl:node-set( \$columns )/*" mode="table-data">
												<xsl:with-param name="current-url" select="current()" />
											</xsl:apply-templates>
										</xsl:when>
										<xsl:when test="function-available( 'msxsl:node-set' )">
											<xsl:apply-templates select="msxsl:node-set( \$columns )/*" mode="table-data">
												<xsl:with-param name="current-url" select="current()" />
											</xsl:apply-templates>
										</xsl:when>
										<xsl:otherwise>
											<!-- Fallback: browser doesn't support node-set(), so output just the URL column. -->
											<td>
												<xsl:apply-templates select="sitemap:loc" mode="table-data" />
											</td>
										</xsl:otherwise>
									</xsl:choose>
								</tr>
							</xsl:for-each>
						</tbody>
					</table>
				</div>
			</body>
		</html>
	</xsl:template>

	<!--
		Output an HTML "th" element for a column heading.
	  -->
	<xsl:template match="wp:column" mode="table-header">
		<th>
			<xsl:call-template name="maybe-add-css-class" />

			<xsl:variable name="heading" select="normalize-space( \$column-headings/wp:column-heading[@namespace-uri = current()/@namespace-uri and @local-name = current()/@local-name] )" />

			<xsl:choose>
				<xsl:when test='\$heading'>
					<xsl:value-of select='\$heading' />
				</xsl:when>
				<xsl:otherwise>
					<xsl:call-template name="ucfirst">
						<xsl:with-param name="str" select="@local-name" />
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
		</th>
	</xsl:template>

	<!--
		Output an HTML "a" element for Q{http://www.sitemaps.org/schemas/sitemap/0.9}loc.
	  -->
	<xsl:template match="sitemap:loc" mode="table-data">
		<a href="{.}">
			<xsl:value-of select="." />
		</a>
	</xsl:template>

	<!--
		Output the text content of all other element children of Q{http://www.sitemaps.org/schemas/sitemap/0.9}url.
	  -->
	<xsl:template match="*" mode="table-data">
		<xsl:value-of select="." />
	</xsl:template>

	<!--
		Output an HTML "td" element for a given column.

		If the \$current-url does not have a child element for this column,
		and empty "td" element will be output.

		@param node \$current-url The current Q{http://www.sitemaps.org/schemas/sitemap/0.9}url element.
	  -->
	<xsl:template match="wp:column" mode="table-data">
		<xsl:param name="current-url" />

		<td>
			<xsl:call-template name="maybe-add-css-class" />
			<xsl:apply-templates select="\$current-url/*[namespace-uri() = current()/@namespace-uri and local-name() = current()/@local-name]" mode="table-data" />
		</td>
	</xsl:template>

	<!--
		Add a CSS class attribute to HTML th/td elements in the result tree for extension elements in the sitemap
		so that plugins can style them differently if they so choose.
	  -->
	<xsl:template name="maybe-add-css-class">
		<xsl:if test="@namespace-uri != 'http://www.sitemaps.org/schemas/sitemap/0.9' or not( @local-name = 'loc' or @local-name = 'lastmod' or @local-name = 'changefreq' or @local-name = 'priority' )">
			<xsl:attribute name="class">
				<xsl:choose>
					<xsl:when test="@namespace-uri = 'http://www.sitemaps.org/schemas/sitemap/0.9'">
						<xsl:if test="not( @local-name = 'loc' or @local-name = 'lastmod' or @local-name = 'changefreq' or @local-name = 'priority' )">
							<!--
								There shouldn't be any other elements in the http://www.sitemaps.org/schemas/sitemap/0.9
								namespace, but currently there can be, so this is necessary for now.
							  -->
							<xsl:text>extension</xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>extension</xsl:text>
						<xsl:text> </xsl:text>
						<xsl:value-of select="@namespace-uri" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>

	<!--
		Poor man's equivalent of PHP's ucfirst() function.

		XSLT/XPath 1.0 does not have a "real" upper-case() function (XPath 2.0 does, but
		no browsers currently support XPath 2.0).

		This will NOT uppercase first characters that are non-ASCII.
	  -->
	<xsl:template name="ucfirst">
		<xsl:param name="str" />

		<xsl:value-of select="
			concat(
				translate(
					substring( \$str, 1, 1 ),
					'abcdefghijklmnopqrstuvwxyz',
					'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
				),
				substring( \$str, 2 )
			)"
		 />
	</xsl:template>
</xsl:stylesheet>

XSL;

		/**
		 * Filter the content of the sitemap stylesheet.
		 *
		 * @param string $xsl Full content for the xml stylesheet.
		 */
		return apply_filters( 'core_sitemaps_stylesheet_content', $xsl_content );
	}

	/**
	 * Returns the escaped xsl for the index sitemaps.
	 */
	public function get_sitemap_index_stylesheet() {
		$css         = $this->get_stylesheet_css();
		$title       = esc_html__( 'XML Sitemap', 'core-sitemaps' );
		$description = sprintf(
			/* translators: %s: URL to sitemaps documentation. */
			__( 'This XML Sitemap is generated by WordPress to make your content more visible for search engines. Learn more about XML sitemaps on <a href="%s">sitemaps.org</a>.', 'core-sitemaps' ),
			__( 'https://www.sitemaps.org/', 'core-sitemaps' )
		);
		$text        = sprintf(
			/* translators: %s: number of URLs. */
			__( 'This XML Sitemap contains %s URLs.', 'core-sitemaps' ),
			'<xsl:value-of select="count(sitemap:sitemapindex/sitemap:sitemap)"/>'
		);

		$url           = esc_html__( 'URL', 'core-sitemaps' );
		$last_modified = esc_html__( 'Last Modified', 'core-sitemaps' );

		$xsl_content = <<<XSL
<?xml version="1.0" encoding="UTF-8"?>
			<xsl:stylesheet version="2.0"
				xmlns:html="http://www.w3.org/TR/REC-html40"
				xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"
				xmlns:sitemap="http://www.sitemaps.org/schemas/sitemap/0.9"
				xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
			<xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/>
			<xsl:template match="/">
				<html xmlns="http://www.w3.org/1999/xhtml">
				<head>
					<title>$title</title>
					<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
					<style type="text/css">
						$css
					</style>
				</head>
				<body>
					<div id="sitemap__header">
						<h1>$title</h1>
						<p>$description</p>
					</div>
					<div id="sitemap__content">
						<p class="text">$text</p>
						<table id="sitemap__table">
							<thead>
							<tr>
								<th>$url</th>
								<th>$last_modified</th>
							</tr>
							</thead>
							<tbody>
							<xsl:for-each select="sitemap:sitemapindex/sitemap:sitemap">
								<tr>
									<td>
										<xsl:variable name="itemURL">
											<xsl:value-of select="sitemap:loc"/>
										</xsl:variable>
										<a href="{\$itemURL}">
											<xsl:value-of select="sitemap:loc"/>
										</a>
									</td>
									<td>
										<xsl:value-of select="sitemap:lastmod"/>
									</td>
								</tr>
							</xsl:for-each>
							</tbody>
						</table>

					</div>
				</body>
				</html>
			</xsl:template>
			</xsl:stylesheet>\n
XSL;

		/**
		 * Filter the content of the sitemap index stylesheet.
		 *
		 * @param string $xsl Full content for the xml stylesheet.
		 */
		return apply_filters( 'core_sitemaps_index_stylesheet_content', $xsl_content );
	}

	/**
	 * The CSS to be included in sitemap XSL stylesheets.
	 *
	 * @return string The CSS.
	 */
	protected function get_stylesheet_css() {
		$css = '
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
				color: #444;
			}

			#sitemap__table {
				border: solid 1px #ccc;
				border-collapse: collapse;
			}

			#sitemap__table tr th {
				text-align: left;
			}

			#sitemap__table tr td,
			#sitemap__table tr th {
				padding: 10px;
			}

			#sitemap__table tr:nth-child(odd) td {
				background-color: #eee;
			}

			a:hover {
				text-decoration: none;
			}';

		/**
		 * Filter the css only for the sitemap stylesheet.
		 *
		 * @param string $css CSS to be applied to default xsl file.
		 */
		return apply_filters( 'core_sitemaps_stylesheet_css', $css );
	}

	/**
	 * Get the lookup table for column headings to be used in the sitemap stylesheet.
	 *
	 * @return string
	 */
	protected function get_stylesheet_column_headings() {
		$column_headings = array(
			'http://www.sitemaps.org/schemas/sitemap/0.9' => array(
				'loc'        => esc_html__( 'URL', 'core-sitemaps' ),
				'lastmod'    => esc_html__( 'Last Modified', 'core-sitemaps' ),
				'changefreq' => esc_html__( 'Change Frequency', 'core-sitemaps' ),
				'priority'   => esc_html__( 'Priority', 'core-sitemaps' ),
			)
		);
		/**
		 * Filter the column headings used in the sitemap stylesheet.
		 *
		 * @param array $column_headings Keys are namespace URIs and values are
		 *                               arrays whose keys are local names and
		 *                               whose values are column headings.
		 */
		$column_headings = apply_filters( 'core_sitemaps_stylesheet_column_headings', $column_headings );

		$lookup_table = array();
		foreach ( $column_headings as $namespace_uri => $headings ) {
			foreach ( $headings as $local_name => $heading ) {
				$lookup_table[] = sprintf(
					'<wp:column-heading namespace-uri="%1$s" local-name="%2$s">%3$s</wp:column-heading>',
					$namespace_uri,
					$local_name,
					esc_xml( $heading )
				);
			}
		}

		return implode( "\n", $lookup_table );
	}
}
